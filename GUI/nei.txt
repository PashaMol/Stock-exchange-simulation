КОНСПЕКТ ЛЕКЦИИ №5 - Stack and subroutines


Повторим массивы:
массивом считается последовательность непрерывно лежащих в памяти данных одинакового типа а – с точки зрения язык ассемблера и машинных кодов просто
и одинакого размера потому что тип этих данных мы интерпретируем сами.



Доступ к массиву к элементу массива очень просто устроен потому что мы можем просто взять начальные индекс прибавить к нему индекс умноженный на размер одного элемента и тем самым посчитать положение элмента. Это кстати приводит к тому что если мы работаем с целочисленными массивный то у нас как правило у нас как правило прибавляют 4.


 



Псевдо инструкция la которая в точности совпадает с инструкцией li фактически ей является. Отличается от lа только только семантикой только
тем как мы из толкуем программу. 
Нас на языке ассемблера li говорит нам о том что программист захотел загрузить в регистр просто число а la говорит о том что он туда захотелось грузить адрес.

Зачем нужны подпрограммы?

Они же функции они же процедуры.

Подпрограммы какой-то кусок кода который в течение работы нашей основной программы может выполняться много раз.


Про первый подход: это обеспечить возможность переходить куда-то а потом возвращаться обратно.

Второй подход: копи паста.


Когда бывает нужно повторное использование кода критической функция мы оформляем наши код таким образом чтобы он был параметризирован.

Хотелось бы оформлять наш исходный код таким образом чтобы тело под программы был рассчитано на то что ей могут передать любые допустимые параметры а вызов подпрограммы был устроен таким образом что мы эти параметры туда подставляли.



Значит надо договориться что какие-то регистры при вызове не трогаются.
Там 32 штуки из них использовать можно 20.



Мы можем договориться что какое-то количество регистров вы можем передавать как параметры в процедуру

подпрограмм.


функция:

возвращает значение одинарной или даже

двойной точности. 


подпрограмма 
являются частью вашего кода.

ее можно выполнять больше

чем один раз.

она лежит где-то отдельно в

нашем коде мы на нее перепрыгиваем

с помощью специальной команды

jump.



jump on link собственно который мы будем

использовать в подавляющем большинстве

случаев мы указываем смещение.

глупо использовать разные регистры в качестве

адреса возврата - 

мы потом сами запутаемся. 

возвращение возврат из функций будет

выполняться просто с помощью функций

jr это jump регистр.

пример неправильно написанной

подпрограммы:

 





обязаны не трогать регистр ra.


не решили проблему последующих вызовов

из данной подпрограммы и вызовов

рекурсивных когда подпрограммы

вызывать сама себя.

ra прежде чем вызывать следующий jump

in link а потом его оттуда вспомнить

мы не

определили какие регистры у нас

считаются временными .



программа должна сохранять содержимое

регистров вида с их там 8 штук то есть

мы можем положить в любой регистр с

что-то вызвать под программу а потом

надеяться что в этом регистре с это

ничего не лежит.




тот же самый код

только на этот раз оформленный в

соответствии конвенции:
 а именно

параметры передаются через регистры вида

а три штуки а0 а1 а2, возвращаемое значение

передается через регистр v0.

с точки зрения логики и даже с

точки зрения того какие инструкции мы

используем не изменилось ничего

изменилась только соглашение по

использованию регистров.


Про функции:

нам никто не

запрещает функции делать в

начале-середине,

где угодно ваша задача сделать так чтобы

вы

не пришли случайно пешком выполняя

инструкции подряд. Решения:

поставить их в конце

или сделать entry point.



вы должны всегда помнить что слово not у

вас уже зарезервировано.


метки это просто

замена адресам.

Про стек:
вы туда можем положить

элемент по

одной штуке и это называется положить в

на вершину стека и мы можем оттуда их

снимать то есть забират.ь


то что там последние лежит то что у нас

last in.


операция положить

в стек называется push, операция снять со

стока называется поп.

хотя

конкретно в ассемблере этих операций

нету.

все элементы стека
также как элемента массива одинакового

размера.

стык который хранит элементы разного

размера но тогда он должен надо хранить

еще и размер.


если мы собираемся реализовать так

аппаратно у нас должна быть такая

сущность

в которой лежит адрес вершины стека

текущий адрес вершина.





мы можем придумать архитектуру в которой

операции push и операция поп будут

реализованы аппаратно то есть будет

специально отдельный регист.





использование 29 регистра

для наших дел это просто договорённость.

пока память для степа используется самая

обычная.

никакой
специальной памяти для стока.



стек начинается самого вверх но чтобы

ситуация переполнение стека не приводило

сразу к исключению.


мы получим адрес

который начинается уже на восьмёрку а

это kernels


и попытка туда сходить

приведет к исключению. добавлен небольшой

буфер.

изначально когда мы запускаем

программу. стек pointer у нас равен

именно вот этому числу  


.стык растет сверху вниз.

пример всевозможных команд работа со

стеком.
 

чтобы прочесть не вершину стека

какой-то и на его элемент вы просто

берем умножаем ее на 4 делаем такой

офсет.

нет никакого

автоматической зачистки стык.


плотность компиляция этой штуки очень

высокая ни одна из этих и ни одной из

этих операций не являлся инструкцию.


стек это штука

части чувствительная к порче.



все регистры типа с.
 

конвенции который состоит 10

пунктов:
 
пролог это начало

нашей подпрограммы которые выполняют

часть вот этих вот

конвенциональных действий.


эпилог это часть нашей подпрограммы

который выполняет к ментальные действия.


преамбула это тот код который

выполняется в основной программе перед

вызовом .

Example with preamble, that narrows prologue and epilogue:

 
